# Scannable NeoForge 1.21.1 Migration Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Migrate the Scannable Minecraft mod from MC 1.20.4 Architectury multi-loader to MC 1.21.1 NeoForge-only, preserving all existing features.

**Architecture:** Flatten the multi-loader project (common/fabric/forge/neoforge) into a single NeoForge module. Replace all Architectury abstractions with direct NeoForge API calls. Migrate ItemStack NBT storage to DataComponents. Update rendering APIs for 1.21 vertex changes.

**Tech Stack:** NeoForge 21.1.219, ModDevGradle 2.0.140, Java 21, Parchment 2024.11.17, Mojang mappings.

---

## Source Reference

The original 1.20.4 source is at `D:/Coding/Minecraft/Scannable/source/`. The new project will be built at `D:/Coding/Minecraft/Scannable/` (project root). The NeoForge 1.21.1 API research is at `D:/Coding/Minecraft/Scannable/neoforge-1.21.1-research.md`.

## Migration Overview

The migration has 12 tasks organized in dependency order:

1. **Build System** - Gradle, metadata, project structure
2. **API Layer** - ScannerModule, ScanResult, ScanResultProvider interfaces
3. **Config System** - ConfigManager + ModConfigSpec (largely reusable)
4. **DataComponents** - Replace all ItemStack NBT with typed components
5. **Item Registration** - DeferredRegister for all items
6. **Menu/Container Registration** - Menu types and container classes
7. **Energy System** - ComponentEnergyStorage replacing NBT-backed energy
8. **Network Packets** - CustomPacketPayload replacing Architectury NetworkManager
9. **Scanner Module Implementations** - All 9 module singletons + filters
10. **Capabilities & Mod Entry** - RegisterCapabilitiesEvent + @Mod class
11. **Client Rendering** - Shaders, ScanManager, overlays, GUI screens
12. **Resources** - Access transformers, mixins, data pack paths, recipes, tags

---

## Task 1: Build System & Project Structure

**Goal:** Set up a NeoForge 1.21.1 single-module Gradle project.

**Files:**
- Create: `build.gradle`
- Create: `settings.gradle`
- Create: `gradle.properties`
- Create: `src/main/templates/META-INF/neoforge.mods.toml`
- Copy: `gradle/wrapper/` from source (update if needed)
- Create: `src/main/resources/pack.mcmeta`

**Step 1: Create `settings.gradle`**

```groovy
pluginManagement {
    repositories {
        gradlePluginPortal()
    }
}

plugins {
    id 'org.gradle.toolchains.foojay-resolver-convention' version '1.0.0'
}

rootProject.name = 'scannable'
```

**Step 2: Create `gradle.properties`**

```properties
org.gradle.jvmargs=-Xmx1G
org.gradle.daemon=true
org.gradle.parallel=true
org.gradle.caching=true
org.gradle.configuration-cache=true

parchment_minecraft_version=1.21.1
parchment_mappings_version=2024.11.17

minecraft_version=1.21.1
minecraft_version_range=[1.21.1]
neo_version=21.1.219
loader_version_range=[1,)

mod_id=scannable
mod_name=Scannable
mod_license=MIT
mod_version=1.8.0
mod_group_id=li.cil.scannable
mod_authors=fnuecke
mod_description=Scannable adds a scanner item to find specific blocks and entities nearby.
```

**Step 3: Create `build.gradle`**

```groovy
plugins {
    id 'java-library'
    id 'net.neoforged.moddev' version '2.0.140'
    id 'idea'
}

version = mod_version
group = mod_group_id

base {
    archivesName = mod_id
}

java.toolchain.languageVersion = JavaLanguageVersion.of(21)

neoForge {
    version = project.neo_version

    parchment {
        mappingsVersion = project.parchment_mappings_version
        minecraftVersion = project.parchment_minecraft_version
    }

    runs {
        client {
            client()
        }
        server {
            server()
            programArgument '--nogui'
        }
        data {
            data()
            programArguments.addAll '--mod', project.mod_id, '--all',
                '--output', file('src/generated/resources/').getAbsolutePath(),
                '--existing', file('src/main/resources/').getAbsolutePath()
        }
        configureEach {
            logLevel = org.slf4j.event.Level.DEBUG
        }
    }

    mods {
        "${mod_id}" {
            sourceSet(sourceSets.main)
        }
    }
}

sourceSets.main.resources { srcDir 'src/generated/resources' }

var generateModMetadata = tasks.register("generateModMetadata", ProcessResources) {
    var replaceProperties = [
        minecraft_version      : minecraft_version,
        minecraft_version_range: minecraft_version_range,
        neo_version            : neo_version,
        loader_version_range   : loader_version_range,
        mod_id                 : mod_id,
        mod_name               : mod_name,
        mod_license            : mod_license,
        mod_version            : mod_version,
        mod_authors            : mod_authors,
        mod_description        : mod_description,
    ]
    inputs.properties replaceProperties
    expand replaceProperties
    from "src/main/templates"
    into "build/generated/sources/modMetadata"
}
sourceSets.main.resources.srcDir generateModMetadata
neoForge.ideSyncTask generateModMetadata

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

idea {
    module {
        downloadSources = true
        downloadJavadoc = true
    }
}
```

**Step 4: Create `src/main/templates/META-INF/neoforge.mods.toml`**

```toml
modLoader="javafml"
loaderVersion="${loader_version_range}"
license="${mod_license}"
issueTrackerURL="https://github.com/MightyPirates/Scannable/issues"

[[mods]]
modId="${mod_id}"
version="${mod_version}"
displayName="${mod_name}"
logoFile="logo.png"
authors="${mod_authors}"
description='''${mod_description}'''

[[mixins]]
config="${mod_id}.mixins.json"

[[dependencies.${mod_id}]]
    modId="neoforge"
    type="required"
    versionRange="[${neo_version},)"
    ordering="NONE"
    side="BOTH"

[[dependencies.${mod_id}]]
    modId="minecraft"
    type="required"
    versionRange="${minecraft_version_range}"
    ordering="NONE"
    side="BOTH"
```

**Step 5: Create source directory structure**

```
src/main/java/li/cil/scannable/
    api/
        scanning/
        prefab/
    common/
        config/
        container/
        energy/
        inventory/
        item/
        network/
            message/
        scanning/
            filter/
        tags/
    client/
        audio/
        gui/
        renderer/
        scanning/
            filter/
        shader/
    mixin/
    util/
        config/
src/main/resources/
    META-INF/
    assets/scannable/
    data/scannable/
src/main/templates/
    META-INF/
```

**Step 6: Copy Gradle wrapper from source**

Copy `source/gradle/`, `source/gradlew`, `source/gradlew.bat` to project root. Update `gradle/wrapper/gradle-wrapper.properties` to Gradle 8.10+ if needed.

**Step 7: Verify build compiles (empty mod)**

Create a minimal `Scannable.java` entry point:

```java
package li.cil.scannable;

import net.neoforged.bus.api.IEventBus;
import net.neoforged.fml.ModContainer;
import net.neoforged.fml.common.Mod;

@Mod(Scannable.MOD_ID)
public class Scannable {
    public static final String MOD_ID = "scannable";

    public Scannable(IEventBus modEventBus, ModContainer modContainer) {
    }
}
```

Run: `./gradlew build`
Expected: BUILD SUCCESSFUL

**Step 8: Commit**

```bash
git add -A
git commit -m "feat: scaffold NeoForge 1.21.1 project structure"
```

---

## Task 2: API Layer

**Goal:** Port the `api/` package. These are interfaces with no platform dependencies.

**Files:**
- Create: `src/main/java/li/cil/scannable/api/API.java`
- Create: `src/main/java/li/cil/scannable/api/scanning/ScannerModule.java`
- Create: `src/main/java/li/cil/scannable/api/scanning/BlockScannerModule.java`
- Create: `src/main/java/li/cil/scannable/api/scanning/EntityScannerModule.java`
- Create: `src/main/java/li/cil/scannable/api/scanning/ScanResult.java`
- Create: `src/main/java/li/cil/scannable/api/scanning/ScanResultProvider.java`
- Create: `src/main/java/li/cil/scannable/api/scanning/ScanResultRenderContext.java`
- Create: `src/main/java/li/cil/scannable/api/prefab/AbstractScanResultProvider.java`
- Source: `source/common/src/main/java/li/cil/scannable/api/`

**Step 1: Copy all API files from `source/common/.../api/` to `src/main/java/.../api/`**

**Step 2: Apply ResourceLocation changes**

Replace all `new ResourceLocation(...)` calls:
- `new ResourceLocation("scannable", "path")` → `ResourceLocation.fromNamespaceAndPath("scannable", "path")`
- `new ResourceLocation("modid:path")` → `ResourceLocation.parse("modid:path")`

**Step 3: Update `ScanResultProvider.java` registry key**

The custom registry key definition changes from Architectury to NeoForge:
```java
// Old (Architectury)
ResourceKey<Registry<ScanResultProvider>> REGISTRY = RegistryUtils.builder(...)

// New (NeoForge)
ResourceKey<Registry<ScanResultProvider>> REGISTRY_KEY =
    ResourceKey.createRegistryKey(ResourceLocation.fromNamespaceAndPath("scannable", "scan_result_provider"));
```

**Step 4: Update `AbstractScanResultProvider.java`**

This class uses access-widened `RenderType.create()` and several `RenderStateShard` internals. These will need Access Transformer entries (Task 12), but for now port the code with the assumption ATs will be in place.

Also update any vertex API calls:
- `.vertex()` → `.addVertex()`
- `.color(r,g,b,a)` → `.setColor(r,g,b,a)`
- `.uv()` → `.setUv()`
- `.uv2()` → `.setLight()`
- Remove `.endVertex()` calls

**Step 5: Verify compilation**

Run: `./gradlew build`

**Step 6: Commit**

```bash
git add src/main/java/li/cil/scannable/api/
git commit -m "feat: port API layer with ResourceLocation and vertex API updates"
```

---

## Task 3: Config System

**Goal:** Port the annotation-based ConfigManager and config classes. The custom config framework backed by ModConfigSpec is largely reusable.

**Files:**
- Create: `src/main/java/li/cil/scannable/util/ConfigManager.java`
- Create: `src/main/java/li/cil/scannable/util/config/` (all 12 annotation files)
- Create: `src/main/java/li/cil/scannable/common/config/CommonConfig.java`
- Create: `src/main/java/li/cil/scannable/common/config/Constants.java`
- Create: `src/main/java/li/cil/scannable/common/config/Strings.java`
- Create: `src/main/java/li/cil/scannable/client/ClientConfig.java`
- Source: `source/common/.../util/ConfigManager.java`, `source/common/.../util/config/`, `source/common/.../common/config/`, `source/common/.../client/ClientConfig.java`
- Source (impl): `source/neoforge/.../util/neoforge/ConfigManagerImpl.java`, `source/neoforge/.../common/config/neoforge/CommonConfigImpl.java`, `source/neoforge/.../client/neoforge/ClientConfigImpl.java`

**Step 1: Copy all config annotation files from `source/common/.../util/config/`**

These are pure Java annotations with no platform deps. Copy as-is.

**Step 2: Port `ConfigManager.java`**

- Copy from `source/common/.../util/ConfigManager.java`
- Remove `@ExpectPlatform` from `add()` and `initialize()` methods
- Inline the NeoForge implementation from `source/neoforge/.../util/neoforge/ConfigManagerImpl.java`
- The `fillSpec()` method that builds `ModConfigSpec` from reflection is reusable as-is
- Update `initialize()` to accept `ModContainer` parameter instead of using `ModLoadingContext.get()`
- `ModLoadingContext.get().registerConfig(type, spec)` → `modContainer.registerConfig(type, spec)`

**Step 3: Port `CommonConfig.java`**

- Copy from `source/common/.../common/config/CommonConfig.java`
- Remove `@ExpectPlatform` annotations from `getDefaultCommonOreTags()` and `getDefaultChestsTags()`
- Inline NeoForge defaults from `source/neoforge/.../common/config/neoforge/CommonConfigImpl.java`
- The defaults use `Tags.Blocks.ORES_COAL`, `Tags.Blocks.ORES_IRON`, etc. - these are NeoForge tags, verify they exist in 1.21.1

**Step 4: Port `ClientConfig.java`**

- Copy from `source/common/.../client/ClientConfig.java`
- Remove `@ExpectPlatform` from `getDefaultBlockTagColors()`
- Inline from `source/neoforge/.../client/neoforge/ClientConfigImpl.java`

**Step 5: Port `Constants.java` and `Strings.java`**

Copy as-is from `source/common/.../common/config/`. Update any `ResourceLocation` constructors.

**Step 6: Verify compilation**

Run: `./gradlew build`

**Step 7: Commit**

```bash
git add src/main/java/li/cil/scannable/util/ src/main/java/li/cil/scannable/common/config/ src/main/java/li/cil/scannable/client/ClientConfig.java
git commit -m "feat: port config system with inlined NeoForge implementations"
```

---

## Task 4: DataComponents

**Goal:** Define custom DataComponentTypes to replace all ItemStack NBT usage.

**Files:**
- Create: `src/main/java/li/cil/scannable/common/data/ModDataComponents.java`

**Step 1: Identify all NBT data stored on ItemStacks**

From source analysis:
1. **ScannerContainer** (`ScannerContainer.java`): Stores 9 item slots as `CompoundTag` with `ListTag` of items → Need `ItemContainerContents` component
2. **ScannerEnergyStorage** (`ScannerEnergyStorage.java`): Stores `int energy` → Use NeoForge's built-in `ComponentEnergyStorage` with `DataComponentType<Integer>`
3. **ConfigurableBlockScannerModuleItem**: Stores `ListTag` of `ResourceLocation` strings (block IDs) → Need `DataComponentType<List<ResourceLocation>>`
4. **ConfigurableEntityScannerModuleItem**: Stores `ListTag` of `ResourceLocation` strings (entity type IDs) → Need `DataComponentType<List<ResourceLocation>>`

**Step 2: Create `ModDataComponents.java`**

```java
package li.cil.scannable.common.data;

import com.mojang.serialization.Codec;
import io.netty.buffer.ByteBuf;
import net.minecraft.core.component.DataComponentType;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.item.component.ItemContainerContents;
import net.neoforged.neoforge.registries.DeferredRegister;

import java.util.List;
import java.util.function.Supplier;

public final class ModDataComponents {
    public static final DeferredRegister.DataComponents COMPONENTS =
        DeferredRegister.createDataComponents("scannable");

    // Energy stored in scanner (used by ComponentEnergyStorage)
    public static final Supplier<DataComponentType<Integer>> ENERGY =
        COMPONENTS.registerComponentType("energy",
            builder -> builder
                .persistent(Codec.INT)
                .networkSynchronized(ByteBufCodecs.VAR_INT));

    // Scanner inventory contents (9 module slots)
    public static final Supplier<DataComponentType<ItemContainerContents>> SCANNER_INVENTORY =
        COMPONENTS.registerComponentType("scanner_inventory",
            builder -> builder
                .persistent(ItemContainerContents.CODEC)
                .networkSynchronized(ItemContainerContents.STREAM_CODEC));

    // Configured block list for configurable block scanner module
    public static final Supplier<DataComponentType<List<ResourceLocation>>> CONFIGURED_BLOCKS =
        COMPONENTS.registerComponentType("configured_blocks",
            builder -> builder
                .persistent(ResourceLocation.CODEC.listOf())
                .networkSynchronized(ResourceLocation.STREAM_CODEC.apply(ByteBufCodecs.list())));

    // Configured entity list for configurable entity scanner module
    public static final Supplier<DataComponentType<List<ResourceLocation>>> CONFIGURED_ENTITIES =
        COMPONENTS.registerComponentType("configured_entities",
            builder -> builder
                .persistent(ResourceLocation.CODEC.listOf())
                .networkSynchronized(ResourceLocation.STREAM_CODEC.apply(ByteBufCodecs.list())));
}
```

**Step 3: Verify compilation**

Run: `./gradlew build`

**Step 4: Commit**

```bash
git add src/main/java/li/cil/scannable/common/data/
git commit -m "feat: define DataComponentTypes replacing ItemStack NBT storage"
```

---

## Task 5: Item Registration

**Goal:** Port all item classes and register them with NeoForge DeferredRegister.

**Files:**
- Create: `src/main/java/li/cil/scannable/common/item/Items.java`
- Create: `src/main/java/li/cil/scannable/common/item/ModItem.java`
- Create: `src/main/java/li/cil/scannable/common/item/ScannerItem.java`
- Create: `src/main/java/li/cil/scannable/common/item/ScannerModuleItem.java`
- Create: `src/main/java/li/cil/scannable/common/item/ConfigurableBlockScannerModuleItem.java`
- Create: `src/main/java/li/cil/scannable/common/item/ConfigurableEntityScannerModuleItem.java`
- Create: `src/main/java/li/cil/scannable/common/tags/ItemTags.java`
- Create: `src/main/java/li/cil/scannable/util/TooltipUtils.java`
- Create: `src/main/java/li/cil/scannable/util/UnitConversion.java`
- Source: `source/common/.../common/item/`, `source/common/.../common/tags/`, `source/common/.../util/TooltipUtils.java`, `source/common/.../util/UnitConversion.java`

**Step 1: Copy utility classes**

Copy `TooltipUtils.java` and `UnitConversion.java` from `source/common/.../util/`. Update `ResourceLocation` constructors.

**Step 2: Copy `ItemTags.java`**

Copy from `source/common/.../common/tags/`. Update `ResourceLocation` constructors.

**Step 3: Port `ModItem.java`**

Copy from source. This is a simple base item class, likely needs no changes beyond `ResourceLocation`.

**Step 4: Port `ScannerModuleItem.java`**

- Copy from `source/common/.../common/item/ScannerModuleItem.java`
- Remove `@ExpectPlatform` from `getModule(ItemStack)`
- The module is now looked up via capability. For NeoForge, inline the impl:
  ```java
  public static Optional<ScannerModule> getModule(ItemStack stack) {
      var module = stack.getCapability(ModCapabilities.SCANNER_MODULE);
      return Optional.ofNullable(module);
  }
  ```
  (ModCapabilities will be defined in Task 10)
- Temporarily, can store the `ScannerModule` reference directly on the item class and return it without capability lookup, since we control all module items.

**Step 5: Port `ScannerItem.java`**

- Copy from `source/common/.../common/item/ScannerItem.java`
- Replace all `stack.getTag()` / `stack.getOrCreateTag()` NBT calls with DataComponent access:
  - Energy: Use `stack.getCapability(Capabilities.EnergyStorage.ITEM)` or `stack.get(ModDataComponents.ENERGY.get())`
  - Inventory: Will use `ScannerContainer` which reads from `ModDataComponents.SCANNER_INVENTORY`

**Step 6: Port `ConfigurableBlockScannerModuleItem.java`**

- Replace `TAG_BLOCKS` NBT access with DataComponents:
  - `stack.getOrCreateTag().getList(TAG_BLOCKS, ...)` → `stack.getOrDefault(ModDataComponents.CONFIGURED_BLOCKS.get(), List.of())`
  - Setting: `stack.set(ModDataComponents.CONFIGURED_BLOCKS.get(), newList)`
- Set default component in Item.Properties: `.component(ModDataComponents.CONFIGURED_BLOCKS.get(), List.of())`

**Step 7: Port `ConfigurableEntityScannerModuleItem.java`**

Same pattern as Step 6 but with `CONFIGURED_ENTITIES`.

**Step 8: Port `Items.java` registration**

- Replace Architectury `RegistryUtils` with NeoForge `DeferredRegister.Items`:

```java
public final class Items {
    public static final DeferredRegister.Items ITEMS = DeferredRegister.createItems("scannable");

    public static final DeferredItem<ScannerItem> SCANNER = ITEMS.registerItem(
        "scanner", ScannerItem::new, new Item.Properties().stacksTo(1)
            .component(ModDataComponents.ENERGY.get(), 0)
            .component(ModDataComponents.SCANNER_INVENTORY.get(), ItemContainerContents.EMPTY));

    public static final DeferredItem<Item> BLANK_MODULE = ITEMS.registerItem(
        "blank_module", ModItem::new);

    // ... all 10 module items
}
```

**Step 9: Verify compilation**

Run: `./gradlew build`

**Step 10: Commit**

```bash
git add src/main/java/li/cil/scannable/common/item/ src/main/java/li/cil/scannable/common/tags/ src/main/java/li/cil/scannable/util/
git commit -m "feat: port item classes with DataComponent storage and DeferredRegister"
```

---

## Task 6: Menu/Container Registration

**Goal:** Port container/menu classes and register MenuTypes.

**Files:**
- Create: `src/main/java/li/cil/scannable/common/container/Containers.java`
- Create: `src/main/java/li/cil/scannable/common/container/ScannerContainerMenu.java`
- Create: `src/main/java/li/cil/scannable/common/container/AbstractModuleContainerMenu.java`
- Create: `src/main/java/li/cil/scannable/common/container/BlockModuleContainerMenu.java`
- Create: `src/main/java/li/cil/scannable/common/container/EntityModuleContainerMenu.java`
- Create: `src/main/java/li/cil/scannable/common/container/ScannerSlot.java`
- Create: `src/main/java/li/cil/scannable/common/inventory/ScannerContainer.java`
- Create: `src/main/java/li/cil/scannable/common/inventory/ContainerSlice.java`
- Source: `source/common/.../common/container/`, `source/common/.../common/inventory/`

**Step 1: Port `ScannerContainer.java`**

Critical NBT → DataComponent migration:
- Old: reads/writes `CompoundTag` on ItemStack via `ContainerHelper.loadAllItems()` / `saveAllItems()`
- New: use `ItemContainerContents` DataComponent:
  ```java
  // Load
  ItemContainerContents contents = stack.getOrDefault(
      ModDataComponents.SCANNER_INVENTORY.get(), ItemContainerContents.EMPTY);
  contents.copyInto(this.getItems());

  // Save
  stack.set(ModDataComponents.SCANNER_INVENTORY.get(),
      ItemContainerContents.fromItems(this.getItems()));
  ```

**Step 2: Port `ContainerSlice.java`**

Copy as-is, no platform deps.

**Step 3: Port `ScannerSlot.java`**

Copy from source. Uses `ItemTags.MODULES` for validation.

**Step 4: Port menu classes**

- `ScannerContainerMenu.java`: Replace `MenuRegistry.ofExtended()` usage. Use NeoForge `IMenuType.create()` for extended menu factory.
- `AbstractModuleContainerMenu.java`, `BlockModuleContainerMenu.java`, `EntityModuleContainerMenu.java`: Copy and update `ResourceLocation` constructors.

**Step 5: Port `Containers.java` registration**

Replace Architectury `RegistryUtils` + `MenuRegistry.ofExtended()`:

```java
public final class Containers {
    public static final DeferredRegister<MenuType<?>> MENUS =
        DeferredRegister.create(Registries.MENU, "scannable");

    public static final Supplier<MenuType<ScannerContainerMenu>> SCANNER =
        MENUS.register("scanner", () -> IMenuType.create(ScannerContainerMenu::new));

    public static final Supplier<MenuType<BlockModuleContainerMenu>> BLOCK_MODULE =
        MENUS.register("block_module", () -> IMenuType.create(BlockModuleContainerMenu::new));

    public static final Supplier<MenuType<EntityModuleContainerMenu>> ENTITY_MODULE =
        MENUS.register("entity_module", () -> IMenuType.create(EntityModuleContainerMenu::new));
}
```

**Step 6: Verify compilation**

Run: `./gradlew build`

**Step 7: Commit**

```bash
git add src/main/java/li/cil/scannable/common/container/ src/main/java/li/cil/scannable/common/inventory/
git commit -m "feat: port menus and containers with DataComponent inventory storage"
```

---

## Task 7: Energy System

**Goal:** Replace the custom NBT-backed ScannerEnergyStorage with NeoForge's ComponentEnergyStorage.

**Files:**
- Create: `src/main/java/li/cil/scannable/common/energy/ItemEnergyStorage.java`
- Source: `source/common/.../common/energy/ItemEnergyStorage.java`, `source/neoforge/.../common/energy/neoforge/ScannerEnergyStorage.java`

**Step 1: Port `ItemEnergyStorage.java` interface**

- Copy from `source/common/.../common/energy/ItemEnergyStorage.java`
- Remove `@ExpectPlatform` from `of(ItemStack)`
- Inline NeoForge implementation:
  ```java
  public static Optional<ItemEnergyStorage> of(ItemStack stack) {
      IEnergyStorage storage = stack.getCapability(Capabilities.EnergyStorage.ITEM);
      if (storage == null) return Optional.empty();
      return Optional.of(new ItemEnergyStorageAdapter(storage));
  }
  ```
  Where `ItemEnergyStorageAdapter` wraps `IEnergyStorage` to the `ItemEnergyStorage` interface (adapting int↔long).

**Step 2: Note on ComponentEnergyStorage**

NeoForge provides `ComponentEnergyStorage` which automatically persists energy to a `DataComponentType<Integer>`. This will be wired up in the capability registration (Task 10):

```java
event.registerItem(Capabilities.EnergyStorage.ITEM,
    (stack, ctx) -> new ComponentEnergyStorage(
        stack, ModDataComponents.ENERGY.get(),
        CommonConfig.energyCapacityScanner, Integer.MAX_VALUE, Integer.MAX_VALUE),
    Items.SCANNER.get());
```

The `useEnergy` config check that was in the old `ScannerEnergyStorage` will need to be handled in `ScannerItem` instead (check config before extracting).

**Step 3: Verify compilation**

Run: `./gradlew build`

**Step 4: Commit**

```bash
git add src/main/java/li/cil/scannable/common/energy/
git commit -m "feat: port energy system using ComponentEnergyStorage"
```

---

## Task 8: Network Packets

**Goal:** Replace Architectury NetworkManager with NeoForge CustomPacketPayload system.

**Files:**
- Create: `src/main/java/li/cil/scannable/common/network/Network.java`
- Create: `src/main/java/li/cil/scannable/common/network/message/SetConfiguredModuleItemAtPayload.java`
- Create: `src/main/java/li/cil/scannable/common/network/message/RemoveConfiguredModuleItemAtPayload.java`
- Source: `source/common/.../common/network/`

**Step 1: Create `SetConfiguredModuleItemAtPayload.java`**

```java
package li.cil.scannable.common.network.message;

import net.minecraft.network.RegistryFriendlyByteBuf;
import net.minecraft.network.codec.ByteBufCodecs;
import net.minecraft.network.codec.StreamCodec;
import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
import net.minecraft.resources.ResourceLocation;

public record SetConfiguredModuleItemAtPayload(
    int windowId,
    int index,
    ResourceLocation value
) implements CustomPacketPayload {

    public static final Type<SetConfiguredModuleItemAtPayload> TYPE =
        new Type<>(ResourceLocation.fromNamespaceAndPath("scannable", "set_module_item"));

    public static final StreamCodec<RegistryFriendlyByteBuf, SetConfiguredModuleItemAtPayload> STREAM_CODEC =
        StreamCodec.composite(
            ByteBufCodecs.VAR_INT, SetConfiguredModuleItemAtPayload::windowId,
            ByteBufCodecs.VAR_INT, SetConfiguredModuleItemAtPayload::index,
            ResourceLocation.STREAM_CODEC, SetConfiguredModuleItemAtPayload::value,
            SetConfiguredModuleItemAtPayload::new);

    @Override
    public Type<? extends CustomPacketPayload> type() { return TYPE; }
}
```

**Step 2: Create `RemoveConfiguredModuleItemAtPayload.java`**

Same pattern with `windowId` + `index` only (no `value`).

**Step 3: Create `Network.java` with registration and handlers**

```java
package li.cil.scannable.common.network;

import net.neoforged.neoforge.network.event.RegisterPayloadHandlersEvent;
import net.neoforged.neoforge.network.registration.PayloadRegistrar;

public final class Network {
    public static void register(RegisterPayloadHandlersEvent event) {
        final PayloadRegistrar registrar = event.registrar("1");

        registrar.playToServer(
            SetConfiguredModuleItemAtPayload.TYPE,
            SetConfiguredModuleItemAtPayload.STREAM_CODEC,
            Network::handleSetConfiguredModuleItem);

        registrar.playToServer(
            RemoveConfiguredModuleItemAtPayload.TYPE,
            RemoveConfiguredModuleItemAtPayload.STREAM_CODEC,
            Network::handleRemoveConfiguredModuleItem);
    }

    // Port handler logic from original AbstractMessage.handleMessage()
    private static void handleSetConfiguredModuleItem(
            SetConfiguredModuleItemAtPayload payload, IPayloadContext context) {
        var player = context.player();
        if (player.containerMenu instanceof AbstractModuleContainerMenu menu
                && menu.containerId == payload.windowId()) {
            menu.setItemAt(payload.index(), payload.value());
        }
    }
    // ... similar for remove
}
```

**Step 4: Verify compilation**

Run: `./gradlew build`

**Step 5: Commit**

```bash
git add src/main/java/li/cil/scannable/common/network/
git commit -m "feat: port network packets to NeoForge CustomPacketPayload system"
```

---

## Task 9: Scanner Module Implementations

**Goal:** Port all 9 scanner module singletons and their filter classes.

**Files:**
- Create: `src/main/java/li/cil/scannable/common/scanning/` (9 module files + ProviderCacheManager + filter/IgnoredBlocks)
- Source: `source/common/.../common/scanning/`
- Source (impl): `source/neoforge/.../common/scanning/neoforge/RareOresBlockScannerModuleImpl.java`, `source/neoforge/.../common/scanning/neoforge/ProviderCacheManagerImpl.java`

**Step 1: Copy all module singletons**

- `RangeScannerModule.java` - No platform deps
- `CommonOresBlockScannerModule.java` - Uses config for tag lists
- `RareOresBlockScannerModule.java` - Has `@ExpectPlatform getTopLevelOreTag()` → inline `Tags.Blocks.ORES`
- `FluidBlockScannerModule.java` - No platform deps
- `ChestScannerModule.java` - No platform deps
- `FriendlyEntityScannerModule.java` - No platform deps
- `HostileEntityScannerModule.java` - No platform deps
- `ConfigurableBlockScannerModule.java` - Reads configured blocks from ItemStack (now DataComponent)
- `ConfigurableEntityScannerModule.java` - Reads configured entities from ItemStack (now DataComponent)

**Step 2: For each module, fix:**

- `ResourceLocation` constructors
- `@ExpectPlatform` → inline NeoForge impl
- NBT reads → DataComponent reads (`stack.getOrDefault(ModDataComponents.CONFIGURED_BLOCKS.get(), List.of())`)

**Step 3: Port `ProviderCacheManager.java`**

- Remove `@ExpectPlatform` from `initialize()`
- Inline: register `ModConfigEvent` listener to call `clearCache()`
- This listener registration will happen in the mod entry class (Task 10)

**Step 4: Port `filter/IgnoredBlocks.java`**

Copy, update `ResourceLocation` constructors.

**Step 5: Verify compilation**

Run: `./gradlew build`

**Step 6: Commit**

```bash
git add src/main/java/li/cil/scannable/common/scanning/
git commit -m "feat: port scanner module implementations with inlined platform code"
```

---

## Task 10: Capabilities & Mod Entry Point

**Goal:** Wire everything together in the `@Mod` entry class. Register capabilities, creative tabs, config, events.

**Files:**
- Modify: `src/main/java/li/cil/scannable/Scannable.java`
- Create: `src/main/java/li/cil/scannable/common/ModCapabilities.java`
- Create: `src/main/java/li/cil/scannable/common/ModCreativeTabs.java`
- Source: `source/neoforge/.../common/neoforge/CommonSetupNeoForge.java`, `source/neoforge/.../common/neoforge/capabilities/Capabilities.java`

**Step 1: Create `ModCapabilities.java`**

```java
package li.cil.scannable.common;

import li.cil.scannable.api.scanning.ScannerModule;
import net.neoforged.neoforge.capabilities.ItemCapability;
import net.minecraft.resources.ResourceLocation;

public final class ModCapabilities {
    public static final ItemCapability<ScannerModule, Void> SCANNER_MODULE =
        ItemCapability.createVoid(
            ResourceLocation.fromNamespaceAndPath("scannable", "scanner_module"),
            ScannerModule.class);
}
```

**Step 2: Create `ModCreativeTabs.java`**

```java
public final class ModCreativeTabs {
    public static final DeferredRegister<CreativeModeTab> TABS =
        DeferredRegister.create(Registries.CREATIVE_MODE_TAB, "scannable");

    public static final DeferredHolder<CreativeModeTab, CreativeModeTab> MAIN =
        TABS.register("common", () -> CreativeModeTab.builder()
            .title(Component.translatable("itemGroup.scannable"))
            .icon(() -> Items.SCANNER.get().getDefaultInstance())
            .displayItems((params, output) -> {
                output.accept(Items.SCANNER.get());
                output.accept(Items.BLANK_MODULE.get());
                // ... all module items
            })
            .build());
}
```

**Step 3: Wire up `Scannable.java` entry point**

```java
@Mod(Scannable.MOD_ID)
public class Scannable {
    public static final String MOD_ID = "scannable";

    public Scannable(IEventBus modEventBus, ModContainer modContainer) {
        // Register all DeferredRegisters
        ModDataComponents.COMPONENTS.register(modEventBus);
        Items.ITEMS.register(modEventBus);
        Containers.MENUS.register(modEventBus);
        ModCreativeTabs.TABS.register(modEventBus);
        ScanResultProviders.PROVIDERS.register(modEventBus);

        // Register config
        ConfigManager.add(CommonConfig::new);
        ConfigManager.add(ClientConfig::new);
        ConfigManager.initialize(modContainer);

        // Register event listeners
        modEventBus.addListener(Network::register);
        modEventBus.addListener(Scannable::registerCapabilities);
        modEventBus.addListener(Scannable::registerRegistries);

        // Config reload → clear caches
        modEventBus.addListener((ModConfigEvent event) -> ProviderCacheManager.clearCache());
    }

    private static void registerCapabilities(RegisterCapabilitiesEvent event) {
        // Energy on scanner
        event.registerItem(Capabilities.EnergyStorage.ITEM,
            (stack, ctx) -> new ComponentEnergyStorage(
                stack, ModDataComponents.ENERGY.get(),
                CommonConfig.energyCapacityScanner, Integer.MAX_VALUE, Integer.MAX_VALUE),
            Items.SCANNER.get());

        // Item handler on scanner
        event.registerItem(Capabilities.ItemHandler.ITEM,
            (stack, ctx) -> new InvWrapper(ScannerContainer.of(stack)),
            Items.SCANNER.get());

        // Scanner module capability on all module items
        event.registerItem(ModCapabilities.SCANNER_MODULE,
            (stack, ctx) -> ((ScannerModuleItem) stack.getItem()).getModule(),
            Items.RANGE_MODULE.get(), Items.ENTITY_MODULE.get(), /* ... all 9 */);
    }

    private static void registerRegistries(NewRegistryEvent event) {
        event.register(ScanResultProviders.REGISTRY);
    }
}
```

**Step 4: Verify compilation**

Run: `./gradlew build`

**Step 5: Commit**

```bash
git add src/main/java/li/cil/scannable/Scannable.java src/main/java/li/cil/scannable/common/ModCapabilities.java src/main/java/li/cil/scannable/common/ModCreativeTabs.java
git commit -m "feat: wire mod entry point with capabilities, creative tabs, and registration"
```

---

## Task 11: Client Rendering & GUI

**Goal:** Port all client-side code: shaders, scan manager, renderers, overlays, GUI screens, sound manager.

**Files:**
- Create: `src/main/java/li/cil/scannable/client/ClientSetup.java`
- Create: `src/main/java/li/cil/scannable/client/ScanManager.java`
- Create: `src/main/java/li/cil/scannable/client/audio/SoundManager.java`
- Create: `src/main/java/li/cil/scannable/client/renderer/ScannerRenderer.java`
- Create: `src/main/java/li/cil/scannable/client/renderer/OverlayRenderer.java`
- Create: `src/main/java/li/cil/scannable/client/shader/Shaders.java`
- Create: `src/main/java/li/cil/scannable/client/scanning/ScanResultProviders.java`
- Create: `src/main/java/li/cil/scannable/client/scanning/ScanResultProviderBlock.java`
- Create: `src/main/java/li/cil/scannable/client/scanning/ScanResultProviderEntity.java`
- Create: `src/main/java/li/cil/scannable/client/scanning/filter/` (8 filter classes)
- Create: `src/main/java/li/cil/scannable/client/gui/` (4 screen classes)
- Source: `source/common/.../client/`, `source/neoforge/.../client/neoforge/`

**Step 1: Port `Shaders.java`**

- Replace `ResourceManagerReloadListener` registration
- Use `RegisterShadersEvent` on mod event bus:
  ```java
  @SubscribeEvent
  public static void registerShaders(RegisterShadersEvent event) throws IOException {
      event.registerShader(
          new ShaderInstance(event.getResourceProvider(),
              ResourceLocation.fromNamespaceAndPath("scannable", "scan_effect"),
              DefaultVertexFormat.POSITION_TEX),
          shader -> scanEffectShader = shader);
      // ... scan_result shader
  }
  ```

**Step 2: Port `ScannerRenderer.java`**

Major changes:
- `Tesselator.getInstance().getBuilder()` → `Tesselator.getInstance().begin(...)`
- `.vertex(x,y,z)` → `.addVertex(x,y,z)`
- `.uv(u,v)` → `.setUv(u,v)`
- Remove `.endVertex()` calls
- `BufferUploader.drawWithShader(builder.buildOrThrow())` replaces `tesselator.end()`
- Remove `@ExpectPlatform copyBufferSettings()` → inline NeoForge impl from `ScannerRendererImpl.java`

**Step 3: Port `OverlayRenderer.java`**

- Register via `RegisterGuiLayersEvent` (was `RegisterGuiOverlaysEvent` in 1.20.4):
  ```java
  @SubscribeEvent
  public static void registerOverlays(RegisterGuiLayersEvent event) {
      event.registerAboveAll(
          ResourceLocation.fromNamespaceAndPath("scannable", "scanner_progress"),
          OverlayRenderer::render);
  }
  ```
- Update rendering vertex API calls

**Step 4: Port `ScanManager.java`**

- Copy from source, update vertex API
- `DeltaTracker` parameter in render methods
- `float partialTick` → `deltaTracker.getGameTimeDeltaPartialTick(false)`

**Step 5: Port `ClientSetup.java`**

This is the client event subscriber. Merge content from `source/neoforge/.../client/neoforge/ClientSetupNeoForge.java`:
- `FMLClientSetupEvent` → register screen factories via `MenuScreens.register()`
- `RegisterGuiLayersEvent` → overlay registration
- `ClientTickEvent.Post` → `ScanManager.tick()`
- `RenderLevelStageEvent` → `ScannerRenderer.render()` (or keep mixin approach)

**Step 6: Port GUI screen classes**

Copy 4 screen classes from `source/common/.../client/gui/`. Update:
- `ResourceLocation` constructors
- Any rendering API changes (vertex, color int, etc.)

**Step 7: Port sound manager**

Copy `SoundManager.java`. Register sound events via DeferredRegister in a new `ModSounds.java` or add to Items/existing class.

**Step 8: Port `ScanResultProviders.java` (custom registry)**

```java
public final class ScanResultProviders {
    public static final Registry<ScanResultProvider> REGISTRY =
        new RegistryBuilder<>(ScanResultProvider.REGISTRY_KEY).sync(true).create();

    public static final DeferredRegister<ScanResultProvider> PROVIDERS =
        DeferredRegister.create(ScanResultProvider.REGISTRY_KEY, "scannable");

    public static final DeferredHolder<ScanResultProvider, ScanResultProviderBlock> BLOCKS =
        PROVIDERS.register("blocks", ScanResultProviderBlock::new);

    public static final DeferredHolder<ScanResultProvider, ScanResultProviderEntity> ENTITIES =
        PROVIDERS.register("entities", ScanResultProviderEntity::new);
}
```

**Step 9: Port `ScanResultProviderBlock.java` and `ScanResultProviderEntity.java`**

These are the largest classes. Key changes:
- Vertex API updates throughout VBO rendering
- `PalettedContainer.get()` access (needs AT entry)
- `Level.getEntities()` access (needs AT entry)
- `BlockState` predicate building unchanged

**Step 10: Port filter classes**

Copy 8 filter classes from `source/common/.../client/scanning/filter/`. Mostly pure logic, update `ResourceLocation` constructors.

**Step 11: Verify compilation**

Run: `./gradlew build`

**Step 12: Commit**

```bash
git add src/main/java/li/cil/scannable/client/
git commit -m "feat: port client rendering, GUI, and scan result providers for 1.21"
```

---

## Task 12: Resources (ATs, Mixins, Assets, Data)

**Goal:** Port all resource files: access transformers, mixins, assets, data packs.

**Files:**
- Create: `src/main/resources/META-INF/accesstransformer.cfg`
- Create: `src/main/resources/scannable.mixins.json`
- Copy: `src/main/resources/assets/scannable/` (textures, models, shaders, sounds, lang)
- Copy: `src/main/resources/data/scannable/` (tags, recipes, advancements)
- Copy: `src/main/resources/pack.mcmeta`

**Step 1: Convert Access Widener → Access Transformer**

Source: `source/common/src/main/resources/scannable.accesswidener`

Convert to `src/main/resources/META-INF/accesstransformer.cfg`:

```
# Scannable Access Transformers
# Converted from Fabric access widener

# RenderType internals for scan result rendering
public net.minecraft.client.renderer.RenderType$CompositeState
public net.minecraft.client.renderer.RenderType create(Ljava/lang/String;Lnet/minecraft/client/renderer/RenderType$CompositeState;)Lnet/minecraft/client/renderer/RenderType;
public net.minecraft.client.renderer.RenderStateShard$ShaderStateShard <init>(Ljava/util/function/Supplier;)V
public net.minecraft.client.renderer.RenderStateShard TRANSLUCENT_TRANSPARENCY
public net.minecraft.client.renderer.RenderStateShard LIGHTNING_TRANSPARENCY
public net.minecraft.client.renderer.RenderStateShard NO_DEPTH_TEST
public net.minecraft.client.renderer.RenderStateShard NO_CULL
public net.minecraft.client.renderer.RenderStateShard COLOR_WRITE
public net.minecraft.client.renderer.RenderStateShard$TextureStateShard

# Block scanning - PalettedContainer.get for reading chunk data
public net.minecraft.world.level.chunk.PalettedContainer get(I)Ljava/lang/Object;

# Render hand control
public net.minecraft.client.renderer.GameRenderer renderHand
public net.minecraft.client.renderer.GameRenderer renderItemInHand(Lnet/minecraft/client/Camera;FLorg/joml/Matrix4f;)V

# Entity scanning
public net.minecraft.world.level.Level getEntities()Lnet/minecraft/world/level/entity/LevelEntityGetter;

# Thread scheduling
public net.minecraft.util.thread.BlockableEventLoop submitAsync(Ljava/lang/Runnable;)Ljava/util/concurrent/CompletableFuture;

# Entity level setter
public net.minecraft.world.entity.Entity setLevel(Lnet/minecraft/world/level/Level;)V
```

**NOTE:** The method descriptors above are approximate. They MUST be verified against the 1.21.1 decompiled source, as method signatures may have changed between 1.20.4 and 1.21.1. In particular:
- `RenderType.create()` parameters may have changed
- `GameRenderer.renderItemInHand()` may now take `DeltaTracker` instead of `float`
- `Level.getEntities()` return type may differ
- Run `./gradlew build` and fix any AT errors based on the actual 1.21.1 signatures

**Step 2: Create mixin config**

Create `src/main/resources/scannable.mixins.json`:
```json
{
    "required": true,
    "package": "li.cil.scannable.mixin",
    "compatibilityLevel": "JAVA_21",
    "minVersion": "0.8",
    "client": [
        "LevelRendererMixin",
        "ScannerItemMixin"
    ],
    "injectors": {
        "defaultRequire": 1
    }
}
```

**Step 3: Port mixin classes**

- Create: `src/main/java/li/cil/scannable/mixin/LevelRendererMixin.java`
  - Copy from `source/common/.../mixin/client/LevelRendererMixin.java`
  - Verify injection target `renderLevel()` signature for 1.21.1 (may take `DeltaTracker` now)
  - Verify the `endOutlineBatch()` call still exists as injection point

- Create: `src/main/java/li/cil/scannable/mixin/ScannerItemMixin.java`
  - Merge from `source/neoforge/.../mixin/neoforge/MixinScannerItem.java`
  - `shouldCauseReequipAnimation()` - uses `IItemExtension`, keep as-is

**Step 4: Copy asset files**

From `source/common/src/main/resources/assets/scannable/`:
- `lang/*.json` (4 language files)
- `models/item/*.json` (11 item models)
- `textures/` (all textures)
- `sounds.json` + `sounds/*.ogg`

For shaders (`shaders/core/`):
- Copy `scan_effect.json`, `scan_effect.fsh`, `scan_result.json`, `scan_result.fsh`
- Review shader JSON for vertex format name changes (e.g., `position_color_tex` → `position_tex_color`)
- Review GLSL code for any uniform/attribute name changes

Copy `logo.png`.

**Step 5: Copy and update data pack files**

From `source/common/src/main/resources/data/scannable/`:

**CRITICAL:** Data pack folder paths are depluralised in 1.21:
- `tags/items/` → `tags/item/`
- `tags/blocks/` → `tags/block/`
- `recipes/` → `recipe/`
- `advancements/` → `advancement/`

Copy files into the new paths:
- `data/scannable/tags/item/modules.json`
- `data/scannable/advancement/recipes/...`

From `source/neoforge/src/main/resources/data/`:
- Copy NeoForge ore block tags: `data/neoforge/tags/block/ores/*.json` (if still needed)
- Copy recipes: `data/scannable/recipe/*.json`

Verify that `c:ores/...` convention tags are correct for NeoForge 1.21.1 (may have changed from `forge:ores/...`). NeoForge 1.21 uses the `c` (common) namespace for convention tags.

**Step 6: Create `pack.mcmeta`**

```json
{
    "pack": {
        "description": "Scannable",
        "pack_format": 34
    }
}
```

Pack format 34 is for MC 1.21-1.21.1.

**Step 7: Verify full build**

Run: `./gradlew build`
Expected: BUILD SUCCESSFUL

Fix any compilation errors, especially:
- AT signature mismatches
- Mixin injection target changes
- Missing imports from moved vanilla classes

**Step 8: Commit**

```bash
git add src/main/resources/ src/main/java/li/cil/scannable/mixin/
git commit -m "feat: port resources, access transformers, mixins, and data packs for 1.21.1"
```

---

## Post-Migration Verification

After all 12 tasks are complete:

1. **Run `./gradlew runClient`** - Verify the game launches with the mod loaded
2. **Check creative tab** - All scanner + module items present
3. **Craft scanner** - Verify recipes work
4. **Test scanning** - Equip modules, use scanner, verify scan wave renders
5. **Test configurable modules** - Open GUI, add blocks/entities, verify DataComponent persistence
6. **Test energy** - If energy is enabled, verify charging and draining
7. **Test with other mods** - Verify capability interop (energy from other mods)

---

## Risk Areas

| Area | Risk | Mitigation |
|------|------|------------|
| Access Transformer signatures | Method sigs changed in 1.21 | Verify against 1.21.1 decompiled source |
| LevelRenderer mixin injection | `renderLevel()` signature changed | Check for `DeltaTracker` parameter |
| Shader JSON format | Attribute names may have changed | Compare with vanilla 1.21.1 shaders |
| Vertex API in ScanResultProviderBlock | Large VBO-heavy class with many vertex calls | Systematic find-replace of vertex methods |
| Convention tags namespace | `forge:` → `c:` in NeoForge 1.21 | Verify all tag references |
| `ItemContainerContents` API | New in 1.21, may have quirks | Test inventory save/load thoroughly |
| `ComponentEnergyStorage` capacity | Config-driven capacity, but component registered at item init | May need custom energy storage that reads config lazily |
